
# Java Base Features

## Java 语言编程规范

1. 枚举类，接口的属性，类中 static final 修饰的属性是常量。
2. 不建议使用一个常量类管理所有常量，推荐按功能设置常量类进行管理。
3. mutable 对象禁止定义为常量，例如 `static final Result SUCCESS = new Result(0, "success")`, 虽然 SUCCESS 引用不可变，但是所指的对象 `Result(0, "success")` 的属性是可变的。
4. 类中声明的顺序：
   1. 类变量
   2. 静态初始化块
   3. 实例变量
   4. 实例初始化块
   5. 构造方法
   6. 方法
5. 大数值写法，添加 `_` 方便看数值大小，例如 `30_000_000`
6. 局部变量，类的成员变量声明时，每行只能声明一个变量
   1. 局部变量需要在创建时声明值。
   2. 类的成员变量要在构造方法内集中声明。
7. float 精度约 6-7 位，double 精度约 15 位，float 和 double 都是浮点数。
   1. NaN 不是一个数字，可以由`0/0`或负数平方根产生，不能用 == 判断一个浮点数是不是NaN, 可以用 `isNaN` 判断一个数是不是 NaN。
   2. 浮点数不能进行精确计算，所以不能用等值判断，但是可以用 `== 0`。
   3. 因为不能等值判断，浮点数不要用做`Map`的key。
   4. 可以用`BigDecimal`进行精确计算，需要用字符串初始化。
8. String 类被 final 修饰，因此不能被继承。
   1. String 类中字符串数组被 `private final` 修饰，表示创建后不可被修改。
9. 不同系统中换行符，文件分隔符不一致，使用 `System.lineSeparator()` 获取换行符，使用`java.io.File`中的`separator`或`pathSeparator`获取文件路径分隔符。
10. 考虑地区语言差异，转换实现时，使用`Locale`指定语言环境，例如`toUpperCase(Locale.Root)`，`String.format(Locale.Root, "%d", 2);`。
11. 主动将敏感信息清0，防止泄露敏感信息。
    1. `Arrays.fill(password, (char) 0x00)`
    2. String 通过反射的方式清零字符串。
12. Java 对应的装箱和拆箱操作。
    1. 不当的代码会有大量的装箱，拆箱操作，影响性能。
    2. 实际应用中优先使用基本类型，包装类型的合理使用场景有：
       - 作为集合中元素，键和值。
       - 作为泛型。
       - 反射方法需要调用包装类。
       - POJO类的属性，RPC方法返回值和参数需要序列化且可能缺失值的场景。
    3. 包装类比较时，应使用`equals()`，`compareTo()`等方法，不要使用 == 进行等值判断。
    4. 包装类型用于数值计算，设计拆箱操作，可能会出现`NullPointException`。
13. 需要使用括号明确运算顺序，比如涉及到位运算操作，多种操作且优先级混淆。
14. 在对象可能为 null 的情况下，要明确处理 null 的场景。对于 `NullPointException` 应在代码中应优先通过预检查的方式消除空指针引用。
15. 断言(assert)可以通过配置关闭和禁用，不建议使用 assert 作为业务代码。
16. 返回值不返回 null，降低程序抛出`NPE`的可能性。
    1. 返回数组的场景，推荐返回长度为0的数组。
    2. 返回集合的场景，推荐返回空集合。
    3. 其他场景使用 `Optional` 代替 null 作为返回值。
       - 禁止对`Optional`对象赋值/返回null，或与 null 比较。
       - 对于`Optional<Integer>`，`Optional<Long>`，`Optional<Double>` 应使用`OptionalInt`, `OptionalLong`, `OptionalDouble`代替。
       - 如果文档注释明确返回值用于数值计算密集型，或者用于序列化，那么可以返回`T`，或者 null，无需 `Optional<T>`。
       - 一般不应返回 `Optional<集合或数组>`，而用空集合或空数组代替。
       - `Optional.of()`参数不能为null，否则也会抛出 NPE 。
17. 不要再父类的构造方法中调用可能被子类重写的方法，在JAVA中，当子类初始化时，会调用父类的构造方法，当父类构造方法调用了被子类覆写的方法，往往会由于子类的初始化未完成而导致异常，并且很难排查。

    
## 类和接口设计指导原则。

1. 设计类时，要为类及其成员设置最小的可访问性。
2. 类要避免定义`public`且非`final`的属性。
3. 匿名类可以考虑使用Lambda表达式或方法引用代替。
4. 覆写`equals()`方法时，应同时覆写`hashCode()`方法，像`HashMap`会将key用`hashCode()`计算哈希值，如果不覆写`HashCode()`，可能会导致相同对象不同的哈希值，导致`HashMap`有两个相同的key。
5. 对方法进行重载时，避免基本类型与其对应的封装类型同时存在的重载。
6. 对于静态方法和属性，应使用类名进行调用。
7. 接口中的方法，属性定义，不需要多余的修饰词，属性默认有 `public static final` 修饰词，方法有 `public abstract` 修饰词。


## 容易混淆的概念

1. 覆写: 父类中实例方法（非static）被子类重新实现。
2. 重载：同一个类中，名字相同但是参数列表不同的方法实现。
3. 隐藏：一个类的属性，静态方法，内部类可以分别隐藏（hide）在其父类中可访问到的具有相同名字（对方法而言是相同的方法签名）的所有属性，静态方法或内部类。
4. 遮蔽：一个变量，方法或类可以分别遮蔽（shadow）在类内部具有相同名字的变量，方法或类。
5. 遮掩：一个变量可以遮掩具有相同名字的一个类，只要他们都在同一个范围内；如果这个名字被用于变量与类都被许可的范围，那么它将引用到变量上。相似的，一个类或者一个类型可以遮掩一个包。

## 正确的单例模式

单例模式确保同一个进程中，单例类只有一个对象，并且该对象对所有其他对象提供访问。
常见的如 Windows 下的资源管理器，Spring Bean 等。

单例的要求：
1. 将其构造方法设为私有，在构造方法中禁止重复实例化对象。
2. 防止对象初始化被多个线程同时运行。
3. 确保该对象不可被序列化。
4. 确保该对象无法克隆。

实例化的代码：

## Java 编写规范

1. 方法行数不超过50行（非空非注释）。
2. 方法参数不超过5个。
   1. 可以尝试相关参数合成一个类。
   2. 构造方法参数过多时，可以考虑使用Builder模式或工厂模式。
   3. 对方法进行抽象和重构。
3. 方法最大代码块嵌套深度不超过4层。
4. 方法抛出的异常类型不超过5类，并通过JavaDoc中@throw标签进行说明。

## Java 编程技巧

1. Java 的 int 和 long，会有最大值限制，如果两数相加数值超过最大值，会产生整数溢出且不能会异常提示，可以使用 `Math.addExact` 计算可能会发生整数溢出的计算。

## 异常概述

异常可分为受检异常（checked exception）和运行时异常（runtime exception）
对于可容错处理，能合理化恢复程序运行的场景使用受检异常。对于编程错误使用运行时异常。

注意点：
1. 异常应只针对真正的异常情况，不应用做流程控制和条件控制。
2. 使用预检查方式尽可能规避运行时异常。
3. 使用异常来作为逻辑业务错误处理，而不是错误码。
4. 方法抛出异常，应与本身的抽象层次相对应。

对于释放资源类操作中发生异常，可以被忽略，一般资源释放类，操作放在 finally 中执行，发生异常指挥导致资源没有释放，不会对程序产生其他影响，不需要执行任何恢复操作。

对于不应该频繁发生的异常，应该将异常信息记录到日志中。

不要直接获取 Throwable, Exception, RuntimeException 等基类异常，捕获异常是为了恢复，不加区分捕获所有异常不利于恢复。

`catch (OneException | Two Exception e)` 使用 | 符号进行或操作，多类异常使用同一个逻辑处理。

保证异常情况下也要正常释放持有的锁
1. 异常条件下，使用的对象内置锁会自动释放，但大多数条件下，Java锁对象需要主动释放锁。
2. 在 finally 代码块中释放锁。

不当的锁使用场景
1. 使用实例锁来同步静态共享变量，实例锁的同步效果仅限于此实例本身，无法用来同步静态共享变量。
2. 使用可被重用的对象来作为锁，如基本数据类型对象。这些对象可能被其他线程或功能重用，进而导致死锁或不正确线程同步行为。
3. 使用 `getClass` 返回的类对象作为锁对象，容易混淆使用子类还是父类进行同步。

## 敏感信息保护

1. 向页面抛出的异常可能会将敏感信息暴露给不信任方。可以使用日志记录原始异常，向页面抛出脱敏异常信息。

## 并发和多线程

原子性：一个操作或多个操作，要么全部执行且执行过程中不被任何因素打断，要么就都不执行。可以通过 synchronized 和 Lock 来保证操作的原子性。

可见性：多个线程同时访问一个变量时，一个线程修改了变量，其他线程能够立即看到修改后的值。

1. Java 提供 volatile 修饰符来保证可见性，变量被修改后的值，会立马被更新到主存中。 
2. 普通的共享变量不能保证可见性，因为普通变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，主存中可能时未被修改的旧值。
3. 通过 synchronized 和 Lock 来保证同一时刻是有一个线程获取锁然后执行同步代码，并在释放锁之前，将变量的更新到主存中。

## 数据竞争（Data Race）happen-before 

两个线程分别对一个非 volatile 共享变量进行访问操作，且至少一个写操作，两个操作之间没有 happen-before 关系。

Java 5 开始，JMM采用 happen-before 关系 （？）

1. 使用队列（BlockingQueue），或其他Java标准库中提供的高级同步机制（executor, future）等。
2. 考虑使用锁来保护共享变量，如果情形简单，容易保证正确，且需要用无锁同步提高性能，可以使用 volatile 变量同步。
3. 前两项性能不理想，可以考虑更完善的无锁同步算法，如果性能仍是问题，考虑采用 `java.util.concurrent.atomic.AtomicXxx`中弱顺序的原子
内存访问。

## 死锁

当多个线程互相持有彼此等待的锁而又不释放自己所持有的锁。

可能出现死锁场景：
1. 异常时未释放锁导致死锁。
2. 请求锁和释放锁的顺序不当导致死锁。
3. 在阻塞操作（网络，文件，控制台I/O和对象序列化）中持有锁，可能导致锁无法正常释放。

## 创建线程的注意事项

1. 创建新线程必须指定线程名
2. 注册 Thread 对象的异常处理 Handler
3. 不依赖线程调度器，线程优先级，yield()方法。
4. 使用合理方法中断线程。

中断线程的方法
1. 禁止使用 `Thread.stop()` 来终止线程。
2. 由业务代码来协作完成，慎用 `Thread.interrupt()`。
3. 优先使用协作式的线程同步机制来通知一个线程终止作业，如`java.uril.concurrent`包中各种synchronizer，加锁的共享变量，
volatile 共享变量等。
4. Java API 推荐做法，让被终止的线程在运行中周期地查询自己是否被终止，如果发现自己被终止，
则应该主动清理状态并终止执行，而不是忽略请求继续执行。


## 线程池

推荐读物 《深入理解线程池》

Java 虚拟机能够管理的线程是有限的，不加控制创建新线程会导致Java虚拟机崩溃。推荐使用线程池来管理线程资源，这样更加明确线程池的运行规则，
避免资源耗尽的风险。

1. 线程池实现，推荐使用 ThreadPoolExecutor，不推荐使用 Executor 来创建线程池。
Executor 允许最大的请求队列和最大的线程数都是 Integer.MAX_VALUE，可能导致OOM。

正确使用线程池的代码
```java
private BlockingQueue blockingQueue = new LinkedBlockingQueue(100);
private ThreadPoolExecutor threadPool = new ThreadPoolExecutor(2, 64, 60L,
    TimeUnit.SECONDS, blockingQueue,
    new SelfThreadFactory("ProductName", "ThreadName", false), 
    new DiscardOldestPolicy(LOGGER, "ThreadName"));
threadPool.execute(new EntityProcessor(entity));
```

线程中任务结束后，必须清理自定义的 ThreadLocal 变量。
1. ThreadLocal 可能是上个任务的值。
2. 线程池中线程会持有 ThreadLocal 的引用，使得ThreadLocal无法被主动释放，导致内存泄漏。

## 双重检查锁

常用于初始化单例。

## 高并发场景注意事项

1. 对于锁，考虑性能损耗，尽量减少加锁的范围，能锁代码时，不要对方法加锁，能对对象加锁，不对类加锁。
2. 高并发场景下，为防止`==`判断被击穿，推荐使用 `>=`，`>`，`<`，`<=` 来做条件判断。
3. 不推荐使用 `ThreadGroup`。
4. 为避免数据竞争，推荐使用不可变对象在多线程间传递信息。


















